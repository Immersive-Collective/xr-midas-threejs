<!DOCTYPE html>
<html>

<head>
    <title>Depth Map Result</title>
    <style type="text/css">

    .im {
        max-width: 15%;
       height: auto;
    }

    #terrain {

        position: absolute;
        display: block;
        left: 0;
        top: 0;
        margin: 0;
        border: 0;
        padding: 0;

    }

    #ui {

        position: absolute;
        z-index: 100;

    }
    </style>
</head>

<body>

    <div id="terrain" style="width: 400px; height: 400px;"></div>

    <div id="ui">
        <img class="im" src="cat.jpg" alt="Original Image" />
        <img class="im" src="depth.jpg" alt="Depth Image" />
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
    "imports": {
      "three": "https://unpkg.com/three@0.156/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.156/examples/jsm/"
    }
  }
</script>
    <script type="module">
        import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let container, stats;
let camera, controls, scene, renderer;
let mesh;

let imageWidth, imageHeight;
let heightData;

const clock = new THREE.Clock();

// Load the Image and initialize
const imageLoader = new THREE.ImageLoader();
imageLoader.load('depth.jpg', function (image) {

    imageWidth = image.width;
    imageHeight = image.height;

    const canvas = document.createElement('canvas');
    canvas.width = imageWidth;
    canvas.height = imageHeight;

    const context = canvas.getContext('2d');
    context.drawImage(image, 0, 0, imageWidth, imageHeight);

    const imgData = context.getImageData(0, 0, imageWidth, imageHeight);
    heightData = new Uint8Array(imageWidth * imageHeight);

    for (let i = 0, j = 0; i < imgData.data.length; i += 4, j++) {
        const r = imgData.data[i];
        const g = imgData.data[i + 1];
        const b = imgData.data[i + 2];
        heightData[j] = (r + g + b) / 3;
    }

    // Load texture for the mesh
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('cat.jpg', function (texture) {
        // Now that the texture is loaded, you can generate the terrain
        
        init(texture);
        
        animate();

    /* */

        // camera.rotation.set({x: 250.00000000000006, y: 800, z: -334})
        // camera.position.set({x: -26.36446344246826, y: 902.3005460944828, z: 41.364404291247155})
        // controls.target.set({x: -25.77834679201264, y: -0.3047741296642187, z: 18.089485277961014})

    /* */



    });

});


function debounce(func, wait) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}


function init(texture) {

    container = document.getElementById('terrain');

    camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 10000);
    
    camera.position.set(imageWidth / 2, 800, -imageHeight / 2);
    camera.lookAt(imageWidth / 2, 0, imageHeight / 2);
    window.camera = camera


    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xefd1b5);
    scene.fog = new THREE.Fog(0xefd1b5, 35, 1200);
    window.scene = scene;

    const geometry = new THREE.PlaneGeometry(imageWidth, imageHeight, imageWidth - 1, imageHeight - 1);
    geometry.rotateX(-Math.PI / 2);

    const vertices = geometry.attributes.position.array;
    for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
        vertices[j + 1] = heightData[i]*3;
    }

    mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture })); 

    mesh.name = "Fantom"

    scene.add(mesh);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Controls
    controls = new OrbitControls(camera, container);
    controls.enableDamping = true;
    controls.dampingFactor = 0.5;
    //controls.minPolarAngle = 0;
    // controls.maxPolarAngle = Math.PI / 2.1; // This is already the default, means camera can't go more than 90 degrees.        
    controls.minDistance = 0; // The closest the camera can get to the target
    controls.maxDistance = 5000; // The farthest the camera can be from the target
    window.controls = controls

    const debouncedSave = debounce(saveCameraPosition, 300); // 300ms delay
    controls.addEventListener('end', debouncedSave); 



    // Stats
    stats = new Stats();
    //container.appendChild(stats.dom);

    window.addEventListener('resize', onWindowResize);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    controls.handleResize();
}

function animate() {
    requestAnimationFrame(animate);
    render();
    //controls.update();
    //stats.update();
}

function render() {


    updateMesh()


    renderer.render(scene, camera);
}



function restoreCameraPosition() {


    if (localStorage.getItem('cameraPositions') && camera) {


      let data = JSON.parse(localStorage.getItem('cameraPositions'))

      let cam = data[data.length-1].camera
      let con = data[data.length-1].controls

      camera.rotation.copy(cam.rotation);
      camera.position.copy(cam.position);

      if(controls) {
        controls.target.copy(con.target)
      }

    } else {

      camera.rotation.copy(JSON.parse(DEFAULT_CAMERA_POS));
      camera.position.copy(JSON.parse(DEFAULT_CAMERA_ROT));
      
      if(controls) {

        controls.target.copy(DEFAULT_CONTROLS_TARGET)
      }

    }

}


function updateMesh() {

    if(scene.getObjectByName("Fantom")) {

        let f = scene.getObjectByName("Fantom");

        f.position.y += 0.2

        f.rotation.y += 0.001


    }

}



let cameraPositions = []

function saveCameraPosition() {


    // Extract and clone the necessary properties from your camera and controls objects.
    const cameraData = {
        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }
    };
    const controlsData = { target: { x: controls.target.x, y: controls.target.y, z: controls.target.z } };
    
    // Store them in the local storage.
    localStorage.setItem('cameraData', JSON.stringify(cameraData));
    localStorage.setItem('controlsData', JSON.stringify(controlsData));

    // Add to the cameraPositions array and store it too.
    cameraPositions.push({
        camera: cameraData,
        controls: controlsData
    });
    localStorage.setItem('cameraPositions', JSON.stringify(cameraPositions));


    let r = JSON.stringify(cameraPositions[cameraPositions.length-1])
    
    console.log(r)



}




</script>
</body>

</html>