<!DOCTYPE html>
<html>

<head>
    <title>XR 2.5</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/main.css') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>

<body id="main-body">

<script type="importmap">
{
  "imports": {
    "three": "{{ url_for('static', filename='libs/three/build/three.module.js') }}",
    "three/addons/": "{{ url_for('static', filename='libs/three/examples/jsm/') }}",
    "gsap": "{{ url_for('static', filename='libs/gsap/index.js') }}",    
    "gsap/plugins/": "{{ url_for('static', filename='libs/gsap/') }}"    
  }
}
</script>

<script type="module">

const container = document.createElement('div');
document.body.appendChild(container);

import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

import { gsap } from "gsap";
import { PixiPlugin } from "gsap/plugins/PixiPlugin.js";
import { MotionPathPlugin } from "gsap/plugins/MotionPathPlugin.js";

/* Colors */ 
import * as cols from '{{ url_for('static', filename='libs/colors/pastels.js') }}';

/* Camera Preseted Positions */
import * as cameraPositionsData from '{{ url_for('static', filename='libs/data/cameraPositions.js') }}'; 
window.cameraPositionsData = cameraPositionsData;

/* Rapier */
import RAPIER from '{{ url_for('static', filename='libs/rapier3d-compat/rapier.es.js') }}';
let stats;
let camera, controls, scene, renderer, meshGroup
let mesh;
let imageWidth, imageHeight;
let heightData;
let xrRefSpace;
let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;
let conS = [];
let bgColor =  Math.random()*1000000000;
const colorsSet = [0xA8E6CE,0xDCEDC2,0xFFD3B5,0xFFAAA6,0xFF8C94]

let textureCube;
let equirectToCubeMap

let envMap1 

let randmFactor = 0.5;
let ballBaseSize = 0.1

let gravity = { x: 0.0, y: -0.2, z: 0.0 };
let ampFactor = 1.2
let colsVariantsIdx = 8

window.gravity = gravity
window.colsVariantsIdx = colsVariantsIdx;

const clock = new THREE.Clock();
let groundHeight = 0;
let eventQueue;

let currentUID = "ff0e2da1-5ba6-4d80-afb5-f97778eabfe2";
window.currentUID = currentUID;

window.myRapierWorld
window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];

async function initRapier() {

    initScene();

    await RAPIER.init();
    
    //console.log(RAPIER)
    
    let world = new RAPIER.World(gravity);
    const eventQueue = new RAPIER.EventQueue(true);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('static/libs/draco'); 
    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    loader.load('{{ url_for('static', filename='models/ring.glb') }}', gltf => {
        let mesh = gltf.scene
        mesh.name = "PAD"
        scene.add(mesh);

        window.cube = mesh;
        
        gltf.scene.traverse(item => {
            if (item.isMesh) {
                const geometry = item.geometry;
                item.material = new THREE.MeshPhongMaterial({ 
                    transparent: true,  opacity: 0.1, 
                    color: 0xFFFFFF, envMap: envMap1, refractionRatio: 0.98, reflectivity: 0.98
                });
                //console.log(geometry)
                const vertices = geometry.attributes.position.array;
                const indices = geometry.index.array;
                const trimesh = new RAPIER.TriMesh(vertices, indices);
                // console.log('TriMesh created successfully', trimesh);
                // console.log('Vertices length:', vertices.length);
                // console.log('Indices length:', indices.length);
                let groundColliderDesc = RAPIER.ColliderDesc.trimesh(trimesh)
                    .setDensity(100)
                    .setTranslation(0, groundHeight, 0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                // this part is a kind of hack...
                groundColliderDesc.shape.indices = indices;
                groundColliderDesc.shape.vertices = vertices;
                let groundCollider = world.createCollider(groundColliderDesc);
                window.groundColliderHandle = groundCollider.handle;
                window.myRapierWorld = world;
                window.eventQueue = eventQueue;
            }
        })

        checkURL()

        animate();

    });

}

let cameraPositions = []

function saveCameraPosition() {

    // Extract and clone the necessary properties from your camera and controls objects.
    const cameraData = {
        position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
        rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }
    };
    const controlsData = { target: { x: controls.target.x, y: controls.target.y, z: controls.target.z } };
    
    // Store them in the local storage.
    localStorage.setItem('cameraData', JSON.stringify(cameraData));
    localStorage.setItem('controlsData', JSON.stringify(controlsData));

    // Add to the cameraPositions array and store it too.
    cameraPositions.push({
        camera: cameraData,
        controls: controlsData
    });
    localStorage.setItem('cameraPositions', JSON.stringify(cameraPositions));

    let r = JSON.stringify(cameraPositions[cameraPositions.length-1])
    console.log(r)

    window.autoRotate = true;


}


function debounce(func, wait) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}

let previousRid = -1;

function getRandomDigit(size) {
    let rid;
    do {
        rid = Math.ceil(Math.random() * size);
    } while (rid === previousRid);

    previousRid = rid;
    return rid;
}

function  animateCameraRandom() {
    let rid = getRandomDigit(4);
    //console.log("rid:",rid)
    animateCamera(rid)
}

let cameraTween, rotationTween, controlsTween;

function animateCamera(id) {

     window.autoRotate = false;

    let c = cameraPositionsData.cameraPosition[id].camera
    let t = cameraPositionsData.cameraPosition[id].controls

    // Save the tweens so we can terminate them later
    cameraTween = gsap.to(camera.position, { duration: 4, x: c.position.x, y: c.position.y, z: c.position.z });
    rotationTween = gsap.to(camera.rotation, { duration: 4, x: c.rotation.x, y: c.rotation.y, z: c.rotation.z });
    controlsTween = gsap.to(controls.target, { duration: 4, x: t.target.x, y: t.target.y, z: t.target.z, onComplete: () => { window.autoRotate = true} });
}

window.animateCamera = animateCamera;

function animateCameraTo(targetPosition, targetRotation, targetControlsTarget) {
    gsap.to(camera.position, { duration: 2, x: targetPosition.x, y: targetPosition.y, z: targetPosition.z });
    gsap.to(camera.rotation, { duration: 2, x: targetRotation.x, y: targetRotation.y, z: targetRotation.z });
    gsap.to(controls.target, { duration: 2, x: targetControlsTarget.x, y: targetControlsTarget.y, z: targetControlsTarget.z });
}
window.animateCameraTo = animateCameraTo;


/* Shaders */
function addRainbow() {
    const rainbowShader = {
        uniforms: {},
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec2 vUv;
            void main() {
                float h = vUv.y;
                vec3 color;
                if(h < 0.2) {
                    color = mix(vec3(0.8, 0.5, 0.6), vec3(0.9, 0.6, 0.8), h / 0.2);
                } else if(h < 0.4) {
                    color = mix(vec3(0.9, 0.6, 0.8), vec3(0.8, 0.7, 0.9), (h - 0.2) / 0.2);
                } else if(h < 0.6) {
                    color = mix(vec3(0.8, 0.7, 0.9), vec3(0.7, 0.9, 1.0), (h - 0.4) / 0.2);
                } else if(h < 0.8) {
                    color = mix(vec3(0.7, 0.9, 1.0), vec3(0.6, 1.0, 0.8), (h - 0.6) / 0.2);
                } else {
                    color = mix(vec3(0.6, 1.0, 0.8), vec3(0.8, 1.0, 0.7), (h - 0.8) / 0.2);
                }
                gl_FragColor = vec4(color, 1.0);
            }
        `
    };
    const rainbowMaterial = new THREE.ShaderMaterial({
        vertexShader: rainbowShader.vertexShader,
        fragmentShader: rainbowShader.fragmentShader,
        side: THREE.BackSide // Render the inside of the geometry, so we see it as a background
    });
    const backgroundGeometry = new THREE.BufferGeometry(2, 2);
    const backgroundMesh = new THREE.Mesh(backgroundGeometry, rainbowMaterial);
    scene.add(backgroundMesh);
}
window.addRainbow = addRainbow;
function dropSomething() {
  if(Math.random()*1 > 0.3) {
    shootBallFromTop()
  }
}
function dumpMachine() {
  setInterval(()=> {
    dropSomething();
  }, 60)
}

/* Ball from camera */

function addBallFromCamera(radius, color, offsetY = 0.2, density = 1) {
    // Get camera position and direction
    const cameraPosition = camera.position;
    const cameraDirection = new THREE.Vector3();
    camera.getWorldDirection(cameraDirection);
    // Apply offset to the Y-component of the camera direction
    cameraDirection.y += offsetY;
    // Normalize the direction vector after applying the offset
    cameraDirection.normalize();
    // Speed factor to apply to the camera direction for the ball velocity
    const speedFactor = 100;
    // Create the rigid body description and set its properties
    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                          .setTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
                          .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
    //let texture = texturesCache[Math.floor(Math.random() * texturesCache.length)].texture;
      // Sphere Core
      const sphereGeometry = new THREE.SphereGeometry(radius,16,12);
      //const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
      const myBallMaterial = new THREE.MeshBasicMaterial({ color: color });
      const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);
      scene.add(sphereMesh);
      // Create the collider
      let colliderDesc = RAPIER.ColliderDesc.ball(radius*1.05).setDensity(density)
      let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
      // Save the collider handle
      window.colliderHandles = window.colliderHandles || [];
      window.colliderHandles.push(collider.handle); 
      // Push the rigid body and the Three.js sphere to the global arrays:
      window.rigidBodies.push(rigidBody);
      window.threeCubes.push(sphereMesh);  // Consider renaming this array for clarity
}
window.addBallFromCamera = addBallFromCamera;


function shootBallFromTop() {
    // Safeguard against undefined myRapierWorld
    if (typeof myRapierWorld === 'undefined' || !myRapierWorld) return;
    let ballSize = ballBaseSize + Math.random() * randmFactor;
    let rf = 5;
    let startY = 40;
    let x = Math.random() * rf * 4 - Math.random() * rf * 4;
    let y = startY + Math.random() * rf - Math.random() * rf;
    let z = -40 + Math.random() * rf - Math.random() * rf;
    let idx = Math.floor(Math.random() * 32);
    let color = cols.variants[window.colsVariantsIdx][idx];
    addBallFromTop(ballSize, color, 0.1, 10, { x: x, y: y, z: z });
}
window.shootBallFromTop = shootBallFromTop;

function addBallFromTop(radius, color, offsetY = 0.2, density = 1, position) {
    const speedFactor = 5 + Math.random() * 5;
    // Ensure that texturesCache is defined and not empty
    // if (!texturesCache || texturesCache.length === 0) {
    //     console.error("texturesCache is undefined or empty");
    //     return;
    // }
    // let textureData = texturesCache[Math.floor(Math.random() * texturesCache.length)];
    // if (!textureData || !textureData.texture) {
    //     console.error("Invalid texture data found in texturesCache");
    //     return;
    // }
    // let texture = textureData.texture;
    // Rigid Body
    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                          .setTranslation(position.x, position.y, position.z)
                          .setLinvel(0 * speedFactor, -1 * speedFactor, 0 * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
    // Sphere Core
    const sphereGeometry = new THREE.SphereGeometry(radius);
    const myBallMaterial = new THREE.MeshPhongMaterial({ 
        color: color, envMap:textureCube, refractionRatio: 0.98, reflectivity: 0.9
    });
//     const myBallMaterial = new THREE.MeshStandardMaterial({ 
// //        map: texture,
//         color: color,
//         wireframe: false,
//         metalness: 0.35,
//         roughness: 0.1,
//         transparent: true,
// //        bumpMap: texture,
//         bumpScale: 1,
//         opacity: 1
//     });
    const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);
    scene.add(sphereMesh);
    sphereMesh.castShadow = true;
    sphereMesh.receiveShadow = true;
    // Collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
    // Save the collider handle
    window.colliderHandles = window.colliderHandles || [];
    //console.log("collider.handle:",collider.handle)
    window.colliderHandles.push(collider.handle);
    // Push to global arrays
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);  // Consider renaming `threeCubes` to a more appropriate name like `threeSpheres`
}
window.addBallFromTop = addBallFromTop;
function shootBall() {
    console.log("shootBall - Spacebar released!");

    let ballSize = 0.7 + Math.random()*0.1;
    // addBallFromCamera(radius, color, offsetY = 0.2, density = 1) {
    
    addBallFromCamera(ballSize, colorsSet[Math.floor(Math.random()*colorsSet.length)], 0.1, 200)
    //addBallFromShotLineEnd(ballSize, colorsSet[Math.floor(Math.random()*colorsSet.length)], 0.1, 1)
    //au.playAudioFromFile(au.findSounds(audioData, "kick2")[0])
}
window.shootBall = shootBall
document.addEventListener('keyup', function(event) {
if (event.keyCode === 32) {
    shootBall()
  }
  if (event.keyCode === 86) {
    dropSomething()
  }
})

document.getElementById('galleryContainer').addEventListener('wheel', function(e) {
    if (e.deltaY !== 0) {
        // Multiply e.deltaY by any desired pixel amount, it's a factor to determine speed
        this.scrollLeft += e.deltaY * 2;
        console.log(e)
        e.preventDefault(); // prevent default vertical scroll
    }
});

function logEvents() {
    // window.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
    //     //console.log("Inside drainCollisionEvents. Handle1:", handle1, "Handle2:", handle2, "Started:", started);
    //     if (handle1 === window.liftColliderHandle || handle2 === window.liftColliderHandle) {
    //         let ballHandle = handle1 === window.liftColliderHandle ? handle2 : handle1;
    //         console.log(`Monkey is involved in a collision event with ball: ${ballHandle}`);
    //         // If the collision has stopped and this ball handle hasn't been handled already
    //         if (!started && !window.handledBalls.includes(ballHandle)) {
    //             incrementPoints(ballHandle);  // Pass the ball handle to the incrementPoints function
    //         }
    //     }
    // });
}

function updateRapier() {
    if (window.myRapierWorld && window.rigidBodies && window.threeCubes) {
        // Check if sizes match
        if (window.rigidBodies.length !== window.threeCubes.length) {
            console.error("Mismatched sizes: rigidBodies vs threeCubes");
            return;
        }
        window.myRapierWorld.step(window.eventQueue);
        for (let i = 0; i < window.rigidBodies.length; i++) {
            if (window.rigidBodies[i].bodyType() == 0) {
                let position = window.rigidBodies[i].translation();
                let rotation = window.rigidBodies[i].rotation();
                // Check if position and rotation are valid before setting
                if (position && rotation) {
                    window.threeCubes[i].position.set(position.x, position.y, position.z);
                    window.threeCubes[i].quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
                } else {
                    console.warn(`Invalid position or rotation at index ${i}`);
                }
            }
        }
        logEvents();
    }
}

function exportGLB(mesh) {
    const exporter = new GLTFExporter();
    let glbData;
    exporter.parse(mesh, (result) => {
        const binary = new Blob([result], { type: 'application/octet-stream' });
        glbData = binary;
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        const url = URL.createObjectURL(glbData);
        link.href = url;
        link.download = 'model.glb';
        link.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(link);
    }, { binary: true });
}

window.exportGLB = exportGLB;
function exportGLTF(mesh) {
    const exporter = new GLTFExporter();
    let gltfData;
    exporter.parse(mesh, (result) => {
        if (result instanceof ArrayBuffer) {
            gltfData = result;
        } else {
            const output = JSON.stringify(result, null, 2);
            gltfData = new Blob([output], { type: 'text/plain' });
        }
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        const url = URL.createObjectURL(gltfData);
        link.href = url;
        link.download = 'model.gltf';
        link.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(link);
    });
}

window.exportGLTF = exportGLTF;
function onXRSessionStart() {
    const session = renderer.xr.getSession();
    console.log("onSessionStart session", session);
    session.requestReferenceSpace('local').then((referenceSpace) => {
        xrRefSpace = referenceSpace;
    });
}

function onXRSessionEnd() {
    console.log("onSessionEnd")
    if (renderer.xr.isPresenting) {
        renderer.xr.end();
    }
}

function initializeThreeJS(uploadedImageUrl, depthImageUrl) {
    removeAllCubes();
    loadDepthImage(uploadedImageUrl, depthImageUrl);
}


function displayPalette(imageName, colors) {


    colors = colors.map(color => `#${color.slice(2)}`);
    let displayText = colors.map(() => `%c  `).join('');  // create a series of space-filled boxes for each color
    let styles = colors.map(color => `background:${color}; padding:5px; border:1px solid ${color};`);
    console.log(displayText, ...styles);

    window.loadedColors = colors



}

let loadedColors
window.loadedColors = loadedColors

function loadPalette(uploadedImageUrl) {

    const paletteUrl = uploadedImageUrl.replace(/_depth(\.[^\.]+)$/, '_colors.json');
    const imageName = paletteUrl.split('/').pop().replace('_colors.json', '');

    console.log("paletteUrl", paletteUrl, "imageName", imageName)

    // Fetch the color palette from the server
    fetch(paletteUrl)
        .then(response => response.json())
        .then(data => {

            const colors = data.colors;

            displayPalette(imageName, data);
        })
        .catch(error => {
            console.error("Error fetching palette:", error);
        });
}


function loadDepthImage(uploadedImageUrl, depthImageUrl) {

    const imageLoader = new THREE.ImageLoader();
    
    imageLoader.load(depthImageUrl, function (image) {

        const scale = 0.05;  // 50% of original size, adjust this value as needed
        imageWidth = Math.floor(image.width * scale);
        imageHeight = Math.floor(image.height * scale);
        const canvas = document.createElement('canvas');
        canvas.width = imageWidth;
        canvas.height = imageHeight;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, imageWidth, imageHeight);
        const imgData = context.getImageData(0, 0, imageWidth, imageHeight);
        heightData = new Uint8Array(imageWidth * imageHeight);
        for (let i = 0, j = 0; i < imgData.data.length; i += 4, j++) {
            const r = imgData.data[i];
            const g = imgData.data[i + 1];
            const b = imgData.data[i + 2];
            heightData[j] = ((r + g + b) / 3) / 10;
        }
        
        window.heightData = heightData;

        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load(uploadedImageUrl, function (texture) {
            
            makeMesh(texture);
            
            loadPalette(depthImageUrl);

        });


    });
}

function loadHDRIAsEnvMap(renderer, path, callback) {
// Usage:
// loadHDRIAsEnvMap(renderer, 'path_to_your.hdri', (envMap) => {
//     someMaterial.envMap = envMap;

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    new RGBELoader().load(path, (texture) => {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        callback(envMap);
        texture.dispose();
        pmremGenerator.dispose();
    });
}


// function equirectangularToCubemap(renderer, equirectangularTexture, size = 512) {
//     // Create a cube camera.
//     const cubeCamera = new THREE.CubeCamera(1, 10, size);
//     cubeCamera.position.set(0, 0, 0);

//     // Create a special scene for rendering.
//     const cubeScene = new THREE.Scene();

//     // Use ShaderMaterial to map equirectangular to the inside of a cube.
//     const equirectangularToCubemapMaterial = new THREE.ShaderMaterial({
//         uniforms: {
//             tEquirect: { value: equirectangularTexture }
//         },
//         vertexShader: /* your vertex shader */,
//         fragmentShader: /* your fragment shader */,
//         side: THREE.BackSide
//     });

//     // Create a large sphere to render the equirectangular map onto.
//     const sphere = new THREE.Mesh(
//         new THREE.SphereBufferGeometry(5, 32, 32),
//         equirectangularToCubemapMaterial
//     );
//     cubeScene.add(sphere);

//     // Render the scene with the cube camera.
//     renderer.render(cubeScene, cubeCamera);

//     return cubeCamera.renderTarget.texture;
// }

// const textureLoader = new THREE.TextureLoader();
// const equirectangularTexture = textureLoader.load("path_to_your_equirectangular_image.jpg");
// const cubemapTexture = equirectangularToCubemap(renderer, equirectangularTexture);


function loadVoronoiSkyboxHex(hexColors) {




const vertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fragmentShader = `
    uniform vec2 points[32];
    uniform int numPoints;
    uniform vec3 colors[32];
    varying vec2 vUv;

    void main() {
        float minDist = 2.0;
        int minIndex = 0;
        for(int i = 0; i < numPoints; i++) {
            vec2 p = points[i];
            float dist = length(vUv - p);
            if(dist < minDist) {
                minDist = dist;
                minIndex = i;
            }
        }
        
        // Calculate the distance from the Voronoi point for gradient effect
        float distanceFromPoint = length(vUv - points[minIndex]);

        // You can adjust the gradient's reach here
        float gradientSize = 0.1;

        // Use smoothstep to create a smooth gradient effect between two colors 
        // based on the distance from the Voronoi point.
        vec3 gradientColor = mix(colors[minIndex], vec3(1.0, 1.0, 1.0), smoothstep(0.0, gradientSize, distanceFromPoint));

        gl_FragColor = vec4(gradientColor, 1.0);
    }
`;

// ... (the rest remains the same)



    // const fragmentShader = `
    //     uniform vec2 points[32];
    //     uniform int numPoints;
    //     uniform vec3 colors[32];
    //     varying vec2 vUv;

    //     void main() {
    //         float minDist = 2.0;
    //         int minIndex = 0;
    //         for(int i = 0; i < numPoints; i++) {
    //             vec2 p = points[i];
    //             float dist = length(vUv - p);
    //             if(dist < minDist) {
    //                 minDist = dist;
    //                 minIndex = i;
    //             }
    //         }
            
    //         gl_FragColor = vec4(colors[minIndex], 1.0);
    //     }
    // `;

    const pointsArray = [];
    const MAX_POINTS = 32;
    for(let i = 0; i < MAX_POINTS; i++) {
        pointsArray.push(new THREE.Vector2(Math.random(), Math.random()));
    }

    // Convert hex color strings to RGB vec3 format
    // const colorArray = hexColors.map(hex => {
    //     const r = parseInt(hex.slice(1, 3), 16) / 255;
    //     const g = parseInt(hex.slice(3, 5), 16) / 255;
    //     const b = parseInt(hex.slice(5, 7), 16) / 255;
    //     return new THREE.Vector3(r, g, b);
    // });

    // Convert hex color strings to RGB vec3 format
    const colorArray = hexColors.map(hex => {
        const r = parseInt(hex.slice(2, 4), 16) / 255;
        const g = parseInt(hex.slice(4, 6), 16) / 255;
        const b = parseInt(hex.slice(6, 8), 16) / 255;
        return new THREE.Vector3(r, g, b);
    });


    const voronoiMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.BackSide,
        uniforms: {
            points: { value: pointsArray },
            numPoints: { value: MAX_POINTS },
            colors: { value: colorArray }
        }
    });

    return voronoiMaterial;
}



function loadVoronoiSkybox() {
    const vertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const fragmentShader = `
        uniform vec2 points[32];
        uniform int numPoints;
        varying vec2 vUv;

        void main() {
            float minDist = 2.0;
            for(int i = 0; i < numPoints; i++) {
                vec2 p = points[i];
                float dist = length(vUv - p);
                minDist = min(minDist, dist);
            }
            
            float grayValue = mod(minDist * 150.0, 1.0);
            gl_FragColor = vec4(vec3(grayValue), 1.0);
        }
    `;

    const pointsArray = [];
    const MAX_POINTS = 32;
    for(let i = 0; i < MAX_POINTS; i++) {
        pointsArray.push(new THREE.Vector2(Math.random(), Math.random()));
    }

    const voronoiMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.BackSide,
        uniforms: {
            points: { value: pointsArray },
            numPoints: { value: MAX_POINTS } // or any other number if you want fewer points
        }
    });

    return voronoiMaterial;
}




function loadSkyboxShader() {


    const vertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const fragmentShader = `

        uniform vec3 innerColors[4];
        uniform vec3 outerColors[4];
        uniform int selectedIndex;

        varying vec2 vUv;

        void main() {
            // Calculate the distance from the center of the gradient
            float distanceFromCenter = distance(vUv, vec2(0.5, 0.5));

            // Use the selected index to get the colors
            vec3 innerColor = innerColors[selectedIndex];
            vec3 outerColor = outerColors[selectedIndex];

            // Blend the colors based on distance from the center
            vec3 color = mix(innerColor, outerColor, distanceFromCenter * 2.0);

            gl_FragColor = vec4(color, 1.0);
        }

    `;


    const backgroundMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.BackSide,
        uniforms: {
            innerColors: {
                value: [
                    new THREE.Vector3(0.8, 0.9, 1.0),
                    new THREE.Vector3(0.8, 1.0, 0.9),
                    new THREE.Vector3(1.0, 0.9, 0.7),
                    new THREE.Vector3(1.0, 0.8, 0.9)
                ]
            },
            outerColors: {
                value: [
                    new THREE.Vector3(1.0, 0.8, 0.9),
                    new THREE.Vector3(0.9, 0.8, 1.0),
                    new THREE.Vector3(0.7, 0.9, 1.0),
                    new THREE.Vector3(1.0, 1.0, 0.8)
                ]
            },
            selectedIndex: { value: 0 }
        }
    });


    backgroundMaterial.uniforms.selectedIndex.value = 4;

    return backgroundMaterial;


}

function loadSkyboxTexture(basePath,ext) {

    let directions = ["px", "nx", "py", "ny", "pz", "nz"];
    let textureCubeImage = directions.map(dir => `${basePath}/${dir}.${ext}`);
    let textureCube = new THREE.CubeTextureLoader().load(textureCubeImage);

    textureCube.mapping = THREE.CubeRefractionMapping;
    return textureCube;
}


function createBackgroundSphere() {
    const geometry = new THREE.SphereGeometry(5000, 32, 32); // Large radius 
    //const material = loadVoronoiSkybox();
    const material = loadSkyboxShader();  // Your ShaderMaterial
    const sphere = new THREE.Mesh(geometry, material);
    return sphere;
}


function createBackgroundSphereHex(colors) {
    const geometry = new THREE.SphereGeometry(5000, 32, 32); // Large radius 
    const material = loadVoronoiSkyboxHex(colors);
    //const material = loadSkyboxShader();  // Your ShaderMaterial
    const sphere = new THREE.Mesh(geometry, material);
    return sphere;
}
window.createBackgroundSphereHex = createBackgroundSphereHex;







function cubeVertex(offsetX, offsetY, offsetZ) {
    offsetX = offsetX || 0;
    offsetY = offsetY || 0;
    offsetZ = offsetZ || 0;

    const v = [
        [-1, -1,  1], [1, -1,  1], [1,  1,  1], [-1,  1,  1],
        [-1, -1, -1], [1, -1, -1], [1,  1, -1], [-1,  1, -1]
    ].map(vertex => [
        vertex[0] / 2 + offsetX,
        vertex[1] / 2 + offsetY,
        vertex[2] / 2 + offsetZ
    ]);

    return v.flat();
}

function cubeIndices(baseIndex) {
    baseIndex = baseIndex || 0;

    const i = [
        [0, 1, 2], [2, 3, 0], // front
        [4, 5, 6], [6, 7, 4], // back
        [0, 4, 1], [1, 4, 5], // left
        [1, 5, 2], [2, 5, 6], // right
        [2, 6, 3], [3, 6, 7], // top
        [0, 3, 4], [3, 7, 4]  // bottom
    ].map(face => face.map(val => val + baseIndex));

    return i.flat();
}

function createExtendedCrossGeometry(size) {
    const positions = [
        [0, 0, 0],
        [-size, 0, 0],
        [size, 0, 0],
        [0, -size, 0],
        [0, size, 0],
        [0, 0, -size],
        [0, 0, size]
    ];

    let vertices = [];
    let indices = [];
    positions.forEach((position, idx) => {
        vertices.push(...cubeVertex(...position));
        indices.push(...cubeIndices(8 * idx));
    });

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
    geometry.setIndex(indices);

    return geometry;
}

function createExtendedCrossMesh(size, material) {
    const geometry = createExtendedCrossGeometry(size);
    return new THREE.Mesh(geometry, material);
}




function initScene() {

    console.log("initScene");
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
    window.camera = camera;
    scene = new THREE.Scene();
    window.scene = scene;

    let skyboxPath = "{{ url_for('static', filename='images/skyboxes/x5') }}";
    textureCube = loadSkyboxTexture(skyboxPath,"png");

    renderer = new THREE.WebGLRenderer({ antialias: true, xrCompatible: true });
    renderer.setClearColor(0x000000, 1); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;

    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

    renderer.xr.enabled = true;
    renderer.xr.addEventListener('sessionstart', onXRSessionStart);
    renderer.xr.addEventListener('sessionend', onXRSessionEnd);

    container.appendChild(renderer.domElement);

    //document.body.appendChild(VRButton.createButton(renderer));
    const vrButton = VRButton.createButton(renderer);
    if (navigator.xr) {
        document.body.appendChild(vrButton);
    }

    camera.position.set(0,1.7,20);

    controls = new OrbitControls(camera, renderer.domElement);

    const debouncedSave = debounce(saveCameraPosition, 300); // 300ms delay
    controls.addEventListener('end', debouncedSave);

    // Assuming controls is your instance of OrbitControls
    controls.addEventListener('start', function() {
        
        window.autoRotate = false;

        // Interrupt GSAP animations
        if (cameraTween) cameraTween.kill();
        if (rotationTween) rotationTween.kill();
        if (controlsTween) controlsTween.kill();

    });

    lastTargetPoint = controls.target


    // LIGHTS
    scene.add(new THREE.HemisphereLight(0xFFFFFF, 0xeeeeff, 3.5));
    const light = new THREE.DirectionalLight(0xffffee, 3.5);

    light.position.set(0, 4, 0);
    light.castShadow = true;
    light.shadow.camera.top = 2;
    light.shadow.camera.bottom = -2;
    light.shadow.camera.right = 2;
    light.shadow.camera.left = -3;
    light.shadow.mapSize.set(512, 512);
    
    scene.add(light);

    //scene.background = textureCube;

    // LIGHTS
    const ambient = new THREE.AmbientLight( 0xffffff, 3.5 );       
    scene.add( ambient );


    const backgroundSphere = createBackgroundSphere(); 
    //scene.add(backgroundSphere);
    
    scene.background = textureCube;
    
    //scene.background = loadSkyboxShader()


    // stats = new Stats();
    // stats.dom.id = "myStats"
    
    // document.body.appendChild(stats.domElement);
    // let myStats = document.getElementById("myStats");

    // document.getElementById("myStats").setAttribute("style", "position: fixed; bottom: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;")


    /* Some extras + */

    //const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

    window.addEventListener('resize', onWindowResize);

    document.addEventListener('keyup', function(event) {
        console.log(event.key);
        if (event.key.match(/^\d$/)) {  // Check if the key is a single digit
            //iterateCameraData(event.key)
            animateCamera(event.key)
        }
          // if (event.keyCode === 32) {
          //   shootBall()
          // }
          // if (event.keyCode === 86) {
          //   dropSomething()
          // }
    })

    animate()


}

function removeAllCubes() {
    for (let i = 0; i < window.threeCubes.length; i++) {
        scene.remove(window.threeCubes[i]);
    }
    // Remove from Rapier
    for (let i = 0; i < window.rigidBodies.length; i++) {
        myRapierWorld.removeRigidBody(window.rigidBodies[i]);
    }
    // Clear arrays
    window.threeCubes = [];
    window.rigidBodies = [];
}
window.removeAllCubes = removeAllCubes;

function addPhysics(mesh, geometry, density, position = {x:0,y:0,z:0} , rotation = {x:0,y:0,z:0}, scale=1) {
    let quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(rotation.x, rotation.y, rotation.z, 'XYZ'));
    const speedFactor = 10 + Math.random() * 10;
    // Create the rigid body description and set its properties   
    let rigidBodyDesc = RAPIER.RigidBodyDesc.fixed()
        .setTranslation(position.x, position.y, position.z)
        .setRotation({ w: quat.w, x: quat.x, y: quat.y, z: quat.z })        
        //.setLinvel(0 * speedFactor, -1 * speedFactor, 0 * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
    const vertices = geometry.attributes.position.array;
    const indices = geometry.index.array;
    const trimesh = new RAPIER.TriMesh(vertices, indices);    
    let colliderDesc = RAPIER.ColliderDesc.trimesh(trimesh).setDensity(density)
    colliderDesc.shape.indices = indices;
    colliderDesc.shape.vertices = vertices;  
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(mesh);
}

function smoothHeightData(heightData, windowSize = 0) {
    const smoothedData = new Float32Array(heightData.length);
    for (let i = 0; i < heightData.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = -windowSize; j <= windowSize; j++) {
            if (heightData[i + j] !== undefined) {
                sum += heightData[i + j];
                count++;
            }
        }
        smoothedData[i] = sum / count;
    }
    return smoothedData;
}

function makeMesh(texture) {
    if (meshGroup) {
        scene.remove(meshGroup);
        const meshIndex = window.threeCubes.indexOf(meshGroup);
        if (meshIndex > -1) {
            window.threeCubes.splice(meshIndex, 1);
            window.rigidBodies.splice(meshIndex, 1);
        }
        meshGroup = undefined;
    }
    
    const geometry = new THREE.PlaneGeometry(imageWidth, imageHeight, imageWidth - 1, imageHeight - 1);
    geometry.rotateX(-Math.PI / 2);
    
    const originalVertices = geometry.attributes.position.array;
    const smoothedHeightData = heightData;
    for (let i = 0, j = 0, l = originalVertices.length; i < l; i++, j += 3) {
        originalVertices[j + 1] = smoothedHeightData[i] * ampFactor;
    }
    
    meshGroup = new THREE.Group();
    scene.add(meshGroup);
    texture.encoding = THREE.sRGBEncoding;

    const textureMaterial = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.FrontSide
    });

    const blackMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000, 
        side: THREE.BackSide,
    });

    const wireMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF57BC,
        transparent: true,
        opacity: 1, 
        side: THREE.BackSide,
        wireframe: true
    });

    //scene.background = texture;


    const offset = 0.03;  // You can adjust this value as necessary

    const texturedMesh = new THREE.Mesh(geometry, textureMaterial);
    meshGroup.add(texturedMesh);

    const blackMesh = new THREE.Mesh(geometry, blackMaterial);
    blackMesh.position.y -= offset;
    meshGroup.add(blackMesh);

    const wireMesh = new THREE.Mesh(geometry, wireMaterial);
    wireMesh.position.y -= offset+0.1;
    meshGroup.add(wireMesh);


    window.meshGroup = meshGroup;
    meshGroup.position.set(0, 1.7, -42);
    meshGroup.rotation.x = 1.15;
    addPhysics(meshGroup, geometry, 20, meshGroup.position, meshGroup.rotation, 1);

    window.autoRotate = false;
    animateCameraRandom()

}

function addStaticModel(filePath, name, position) {
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('static/libs/draco');
    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    // Get the base URL and append the filePath
    const baseURL = document.getElementById('baseStaticURL').value;
    const fullURL = baseURL + filePath;

    loader.load(fullURL, gltf => {
        let sceneRoot = gltf.scene;
        sceneRoot.name = name;
        sceneRoot.position.copy(position)

        sceneRoot.traverse((child) => {
            if (child.isMesh) {
                // Add physics to each individual mesh in the model
                addPhysics(child, child.geometry, 40, sceneRoot.position, sceneRoot.rotation, 1);
            }
        });

        scene.add(sceneRoot);

    });
}
window.addStaticModel = addStaticModel;



function addQQ() {

    const qq = createExtendedCrossMesh(1, loadSkyboxShader());
    scene.add(qq)
    qq.position.set(0,2,0)
    addPhysics(qq, qq.geometry, 20, qq.position, qq.rotation, 1);

}
window.addQQ = addQQ;


function addPlane(name = "plane",w=3, h=3, position={x:0,y:0,z:0}) {
    const geometry = new THREE.PlaneGeometry(w,h, w - 1, h - 1);
    mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x1133FE })); 
    mesh.name = name
    mesh.position.set(position)
    scene.add(mesh)
    addPhysics(mesh, geometry)
}
window.addPlane = addPlane;

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

let autoRotate = true;
let rotationAngle = 0;
let rotationRadius = 100;
let initializedFreeFly = false;
let lastTargetPoint;
let easingFactor = 0.00005;
let maxRotationSpeed = 0.001; 

function freeFly() {

    if(scene.getObjectByName("PAD") && window.autoRotate == true) {

        let targetPoint = scene.getObjectByName("PAD").position;

        if (!initializedFreeFly) {
            let dx = camera.position.x - targetPoint.x;
            let dz = camera.position.z - targetPoint.z;
            rotationRadius = Math.sqrt(dx * dx + dz * dz);
            rotationAngle = Math.atan2(dx, dz);
            easingFactor = 0.0001; // Reset easingFactor when freeFly is initialized
            initializedFreeFly = true;
        }

        rotationAngle += easingFactor;

        // Gradually increase the easingFactor until it reaches maxRotationSpeed
        easingFactor = Math.min(easingFactor + 0.00001, maxRotationSpeed); 

        camera.position.x = targetPoint.x + rotationRadius * Math.sin(rotationAngle);
        camera.position.z = targetPoint.z + rotationRadius * Math.cos(rotationAngle);

        camera.lookAt(lastTargetPoint);

    } else {
        initializedFreeFly = false; // Reset for next time
        controls.update();
    }
}

window.autoRotate = autoRotate;



function animate() {

    dumpMachine();

    renderer.setAnimationLoop(render);
}


function render(timeStamp, xrFrame) {


    freeFly();


    // if(controls) {
    //   controls.update();
    
    // }

    if(stats) {
        stats.update()
    }
    
    updateRapier()

    renderer.render(scene, camera);
}

function stripUID(url) {
    //var url = 'http://127.0.0.1:5050/share/c4f81e2d-901a-4101-a801-74a463c0f334/#';
    let regex = /share\/([a-f0-9\-]+)/;
    let match = url.match(regex);
    let uid = match ? match[1] : null;
    return uid;
}


function handleUploadFormSubmission(e) {
    closeGallery();
    const formData = new FormData(document.getElementById('uploadForm'));
    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        
        console.log("data", data)

        // Display the images
        document.getElementById('depth-image').src = `${data.depth_image_url}`
        // Initialize ThreeJS
        window.currentUID = stripUID(data.shareable_link);
        history.pushState("recentShare", "", returnShareURL());

        initializeThreeJS(data.image_url, data.depth_image_url);
        document.getElementById('depth-image').classList.remove('pulsating-image');
    })
    .catch(error => {
        console.error('There was an error uploading the image:', error);
    });
}

document.getElementById('uploadForm').addEventListener('submit', handleUploadFormSubmission);

// Add an event listener for the file input change
document.querySelector('input[type="file"]').addEventListener('change', function() {
    const fileInput = this;
    const previewImg = document.getElementById('preview');
    if (fileInput.files && fileInput.files[0]) {
        const reader = new FileReader();
        reader.onload = function(e) {
            // Set the preview image's src to the loaded data URL
            previewImg.src = e.target.result;
            document.getElementById('depth-image').classList.add('pulsating-image');
        };
        // Read the selected file as a data URL
        reader.readAsDataURL(fileInput.files[0]);
    }
    document.getElementById('uploadForm').dispatchEvent(new Event('submit')); // programmatically submit the form
});

const previewImg = document.getElementById('preview');
const depthImg = document.getElementById('depth-image');
previewImg.onerror = function() {
    this.src = "{{ url_for('static', filename='images/placeholder.png') }}"; // replace with your default image path
};
depthImg.onerror = function() {
    this.src = "{{ url_for('static', filename='images/placeholder.png') }}"; // replace with your default image path
};

/* Github */
document.getElementById("github-link").onclick = () => window.open("https://github.com/Immersive-Collective/xr-midas-threejs","_blank");


/* Gallery */
function loadGallery() {
    fetch("/get-images")
    .then(response => response.json())
    .then(data => {

        //console.log("data", data)

        let gallery = document.getElementById('galleryContainer');
        gallery.innerHTML = '';  // clear the gallery
        data.images.forEach(imgObj => {

            //console.log(imgObj.file, imgObj.uid)

            let originalImg = imgObj.file; // Since you are storing the original filename in the JSON
            let thumbnailImg = originalImg.replace('.', '_th.'); // Assuming you want to display the thumbnail version
            let div = document.createElement('div');
            div.data = imgObj;
            div.classList.add("g-div-before");
            
            // Load the image first using the Image object
            let imageLoader = new Image();
            imageLoader.src = "/uploads/" + thumbnailImg;
            imageLoader.onload = function() {
                div.classList.remove("g-div-before");
                div.classList.add("g-div");
                div.style.backgroundImage = `url(${imageLoader.src})`;

                // div.style.border = "1px solid rgba(0,0,0,0.75)"
            };

            div.onclick = function() {
                //getImage("/uploads/" + originalImg);
                window.currentUID = this.data.uid;
                fetchAndDisplayImageByUUID(this.data.uid)

            };

            gallery.appendChild(div);

        });
        document.getElementById('galleryOverlay').style.display = 'block';
    });
}

function checkURL() {

    const currentURL = new URL(window.location.href);
    const pathSegments = currentURL.pathname.split('/');
    let uid = "{{ uid }}";

    if(uid == "") {
        console.log("uid undefined")
        uid = window.currentUID;
    } else {
        window.currentUID = uid;
    }
    fetchAndDisplayImageByUUID(uid);
}


function fetchAndDisplayImageByUUID(uuid) {
    fetch('/share/' + uuid)
    .then(response => response.json())
    .then(data => {
        const originalUrl = "/uploads/" + data.original_filename;
        getImage(originalUrl);
        window.currentUID = uuid;
        history.pushState("recentShare", "", returnShareURL());
    })
    .catch(error => {
        console.error("Error fetching image by UUID:", error);
    });
}
window.fetchAndDisplayImageByUUID = fetchAndDisplayImageByUUID;


function getImage(originalUrl) {

    document.getElementById('preview').src = originalUrl;
    // Since all depth images are in .jpg format
    let depth_image = originalUrl.replace(/(.*\/)uploads(\/[^\/]+)\.[^\.]+$/, `$1outputs$2_depth.jpg`);
    
    console.log("depth_image =>", depth_image);
    
    document.getElementById('galleryOverlay').style.display = 'none';
    document.getElementById('depth-image').src = depth_image;

    removeAllCubes();

    loadDepthImage(originalUrl, depth_image);

}
window.getImage = getImage;


function closeGallery() {
    document.getElementById('galleryOverlay').style.display = 'none';
}

window.loadGallery = loadGallery;
window.closeGallery = closeGallery;

document.addEventListener("DOMContentLoaded", function() {

    RAPIER.init().then(() => {
        initRapier();
    });

    document.getElementById("main-body").style.visibility = "visible";
    document.getElementById("main-body").style.opacity = 1;


});


function returnShareURL() {
    const parsedURL = new URL(window.location.href);
    const domainAndPort = `${parsedURL.protocol}//${parsedURL.host}`;
    return domainAndPort+'/image/'+window.currentUID
}


document.getElementById('share-link').addEventListener('click', function() {

    const shareURL = returnShareURL() 

    if (navigator.share) {
        // Web Share API is supported
        navigator.share({
            title: 'Immersive Photos',
            text: 'Immersive experience for you: ',
            url: shareURL, // Or any other URL you'd like to share
        }).then(() => {
            console.log('Thanks for sharing!');
        }).catch(console.error);
    } else {
        // Fallback for browsers that don't support the Web Share API
        const textArea = document.createElement('textarea');
        textArea.value = shareURL; // Or any other URL you'd like to share
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert(`URL ${shareURL} copied to clipboard!`);
    }

});


</script>

<input type="hidden" id="baseStaticURL" value="{{ url_for('static', filename='') }}">

<div id="ui" style="padding-bottom: 50px;">

    <div id="imageContainer">
        <img class="im" id="preview" alt="Image Preview" src="{{ url_for('static', filename='images/placeholder.png') }}">
        <img class="im" id="depth-image" alt="Depth Image" src="{{ url_for('static', filename='images/placeholder.png') }}">
    </div>

    <a href="#" id="gallery-link" onclick="loadGallery()" class="btn github-corner" rel="noopener noreferrer" aria-label="View source on GitHub">Gallery</a>

    <div id="github-link" aria-label="View source on GitHub">
        <img id="github-link-icon" src="{{ url_for('static', filename='images/github-mark/github-mark-white.svg') }}" alt="GitHub icon" class="github-icon">
    </div>

    <div id="share-link" aria-label="View source on GitHub">
        <img id="share-link-icon" src="{{ url_for('static', filename='images/share.svg') }}" alt="Share icon" class="share-icon">
    </div>
    
    <form id="uploadForm">
        <label id="file-upload-link" for="file-upload" class="btn custom-file-upload">Upload Image</label>
        <input id="file-upload" type="file" name="file" required style="display:none;" />
    </form>

</div>

<div id="galleryOverlay">
    <div id="galleryContainer">
        <!-- Images will be loaded here from Flask -->
    </div>
</div>




</body>
</html>




