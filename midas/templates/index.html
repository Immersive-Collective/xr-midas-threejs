<!DOCTYPE html>
<html>

<head>
    <title>XR 2.5</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/main.css') }}">
</head>

<body>


<script type="importmap">
{
  "imports": {
    "three": "{{ url_for('static', filename='libs/three/build/three.module.js') }}",
    "three/addons/": "{{ url_for('static', filename='libs/three/examples/jsm/') }}"
  }
}
</script>

<!-- <script type="module" src="{{ url_for('static', filename='libs/rapier/rapier_wasm3d.js') }}"></script>
 -->

<script type="module">

import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
// /Users/smielniczuk/Documents/works/ic/xr-midas-threejs/midas/static/libs/draco


let stats;
let camera, controls, scene, renderer, meshGroup
let mesh;
let imageWidth, imageHeight;
let heightData;
let xrRefSpace;
let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;
let conS = [];
let bgColor =  Math.random()*1000000000;

const container = document.createElement('div');
document.body.appendChild(container);

const clock = new THREE.Clock();


/* Rapier */

let groundHeight = 0;
let eventQueue;

//import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier3d-compat';
import RAPIER from '{{ url_for('static', filename='libs/rapier3d-compat/rapier.es.js') }}';

// OR using the await syntax:
async function run_simulation() {
    await RAPIER.init();
    // Run the simulation.
    console.log(RAPIER)

    let gravity = { x: 0.0, y: -1.8, z: 0.0 };
    let world = new RAPIER.World(gravity);
    const eventQueue = new RAPIER.EventQueue(true);

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('static/libs/draco'); 
    

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);


    loader.load('{{ url_for('static', filename='models/test.glb') }}', gltf => {

        let mesh = gltf.scene
        mesh.name = "PAD"

        scene.add(mesh);
        window.cube = mesh;

        cube.position.z = -20

        controls.target.copy(mesh.position)
        controls.update();


        gltf.scene.traverse(item => {

            if (item.isMesh) {
          
                const geometry = item.geometry;
          
                console.log(geometry)

                const vertices = geometry.attributes.position.array;
                const indices = geometry.index.array;

                const trimesh = new RAPIER.TriMesh(vertices, indices);

                console.log('TriMesh created successfully', trimesh);

                // console.log('Vertices length:', vertices.length);
                // console.log('Indices length:', indices.length);

                let groundColliderDesc = RAPIER.ColliderDesc.trimesh(trimesh)
                    .setDensity(100)
                    .setTranslation(0, groundHeight, 0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);

                //console.log(groundColliderDesc);
                //console.log("groundColliderDesc.shape", groundColliderDesc.shape);

                // this part is a kind of hack, check the
                groundColliderDesc.shape.indices = indices;
                groundColliderDesc.shape.vertices = vertices;


                let groundCollider = world.createCollider(groundColliderDesc);
                window.groundColliderHandle = groundCollider.handle;

                window.myRapierWorld = world;
                window.eventQueue = eventQueue;


            }
        })

    });


}

RAPIER.init().then(() => {
    // Run the simulation.
    run_simulation();
});




function updateRapier() {


    if (window.myRapierWorld && window.rigidBodies) {

        console.log("z")

        //window.myRapierWorld.step();
        window.myRapierWorld.step(window.eventQueue);

        //console.log(window.rigidBodies)

        for(let i = 0; i < window.rigidBodies.length; i++) {

            if(window.rigidBodies[i].bodyType() == 0) {

                let position = window.rigidBodies[i].translation();
                window.threeCubes[i].position.set(position.x, position.y, position.z);

                // Add this part to update the rotation
                let rotation = window.rigidBodies[i].rotation(); // Assuming the rotation method returns a quaternion
                window.threeCubes[i].quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        // - TO DO
        logEvents()


    }
}





function exportGLB(mesh) {
    const exporter = new GLTFExporter();
    let glbData;
    exporter.parse(mesh, (result) => {
        const binary = new Blob([result], { type: 'application/octet-stream' });
        glbData = binary;
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        const url = URL.createObjectURL(glbData);
        link.href = url;
        link.download = 'model.glb';
        link.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(link);
    }, { binary: true });
}
window.exportGLB = exportGLB;


function exportGLTF(mesh) {
    const exporter = new GLTFExporter();
    let gltfData;
    exporter.parse(mesh, (result) => {
        if (result instanceof ArrayBuffer) {
            gltfData = result;
        } else {
            const output = JSON.stringify(result, null, 2);
            gltfData = new Blob([output], { type: 'text/plain' });
        }
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        const url = URL.createObjectURL(gltfData);
        link.href = url;
        link.download = 'model.gltf';
        link.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(link);
    });
}
window.exportGLTF = exportGLTF;

function onXRSessionStart() {
    const session = renderer.xr.getSession();
    console.log("onSessionStart session", session);
    session.requestReferenceSpace('local').then((referenceSpace) => {
        xrRefSpace = referenceSpace;
    });
}

function onXRSessionEnd() {
    console.log("onSessionEnd")
    if (renderer.xr.isPresenting) {
        renderer.xr.end();
    }
}

function initializeThreeJS(uploadedImageUrl, depthImageUrl) {
    loadDepthImage(uploadedImageUrl, depthImageUrl);
}

function loadDepthImage(uploadedImageUrl, depthImageUrl) {
    const imageLoader = new THREE.ImageLoader();
    imageLoader.load(depthImageUrl, function (image) {
        imageWidth = image.width;
        imageHeight = image.height;
        const canvas = document.createElement('canvas');
        canvas.width = imageWidth;
        canvas.height = imageHeight;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, imageWidth, imageHeight);
        const imgData = context.getImageData(0, 0, imageWidth, imageHeight);
        heightData = new Uint8Array(imageWidth * imageHeight);
        for (let i = 0, j = 0; i < imgData.data.length; i += 4, j++) {
            const r = imgData.data[i];
            const g = imgData.data[i + 1];
            const b = imgData.data[i + 2];
            heightData[j] = (r + g + b) / 3;
        }
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(uploadedImageUrl, function (texture) {
            makeMesh(texture);
        });
    });
} 

function makeScene() {

    console.log("makeScene");
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xefd1b5);
    
    renderer = new THREE.WebGLRenderer({ antialias: true, xrCompatible: true });
    renderer.setClearColor(0x000000, 1); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;
    renderer.xr.enabled = true;
    renderer.xr.addEventListener('sessionstart', onXRSessionStart);
    renderer.xr.addEventListener('sessionend', onXRSessionEnd);
    container.appendChild(renderer.domElement);
    
    //document.body.appendChild(VRButton.createButton(renderer));
    const vrButton = VRButton.createButton(renderer);
    if (navigator.xr) {
        document.body.appendChild(vrButton);
    }

    controls = new OrbitControls(camera, renderer.domElement);
    controls.update()
    
    stats = new Stats();
    stats.dom.id = "myStats"
    document.body.appendChild(stats.domElement);
    let myStats = document.getElementById("myStats");
    document.getElementById("myStats").setAttribute("style", "position: fixed; top: 0px; right: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;")

    window.addEventListener('resize', onWindowResize);
    
    animate();

}

function makeMesh(texture) {
    
    const geometry = new THREE.PlaneGeometry(imageWidth, imageHeight, imageWidth - 1, imageHeight - 1);
    geometry.rotateX(-Math.PI / 2);
    const vertices = geometry.attributes.position.array;
    for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
        vertices[j + 1] = heightData[i]*4;
    }
    
    // Check if there's an existing meshGroup in the scene and remove it
    if (meshGroup) {
        scene.remove(meshGroup);
        meshGroup = undefined;
    }

    meshGroup = new THREE.Group();

    scene.add(meshGroup)
    
    window.meshGroup = meshGroup;
    texture.encoding = THREE.sRGBEncoding;
    mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture })); 
    meshGroup.add(mesh);
    
    let sc = 0.01
    mesh.scale.set(sc,sc,sc)

    let someDistance = -12;  
    meshGroup.position.set(0,0,someDistance);
    meshGroup.rotation.set(1.5,0,0);
    
    camera.lookAt(meshGroup.position);
    camera.position.set(0,1.7,0);

    controls.target.copy(meshGroup.position)
    controls.update();


}


function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    renderer.setAnimationLoop(render);
}

function render(timeStamp, xrFrame) {

    if(controls) {
        //console.log("controls")
      controls.update();
    }

    if(stats) {
        stats.update()
    }

    updateRapier()

    renderer.render(scene, camera);
}

makeScene();


function handleUploadFormSubmission(e) {

    const formData = new FormData(document.getElementById('uploadForm'));

    fetch('/upload', {
        method: 'POST',
        body: formData
    })
    
    .then(response => response.json())
    
    .then(data => {

        console.log("data", data)

        // Display the images
        document.getElementById('depth-image').src = `${data.depth_image_url}`
        
        // Initialize ThreeJS
        initializeThreeJS(data.image_url, data.depth_image_url);
        document.getElementById('depth-image').classList.remove('pulsating-image');

    })

    .catch(error => {
        console.error('There was an error uploading the image:', error);
    });
}


document.getElementById('uploadForm').addEventListener('submit', handleUploadFormSubmission);

// Add an event listener for the file input change
document.querySelector('input[type="file"]').addEventListener('change', function() {
    const fileInput = this;
    const previewImg = document.getElementById('preview');

    if (fileInput.files && fileInput.files[0]) {
        const reader = new FileReader();
        
        reader.onload = function(e) {
            // Set the preview image's src to the loaded data URL
            previewImg.src = e.target.result;
            document.getElementById('depth-image').classList.add('pulsating-image');
        };
        
        // Read the selected file as a data URL
        reader.readAsDataURL(fileInput.files[0]);
    }
    
    document.getElementById('uploadForm').dispatchEvent(new Event('submit')); // programmatically submit the form
});


const previewImg = document.getElementById('preview');
const depthImg = document.getElementById('depth-image');

previewImg.onerror = function() {
    this.src = "{{ url_for('static', filename='images/placeholder.jpg') }}"; // replace with your default image path
};

depthImg.onerror = function() {
    this.src = "{{ url_for('static', filename='images/placeholder.jpg') }}"; // replace with your default image path
};


console.log("index.html")


</script>


<div id="ui" style="padding-bottom: 50px;"> <!-- Add padding to account for the fixed button -->
    <div id="imageContainer">
        <img class="im" id="preview" alt="Image Preview" src="{{ url_for('static', filename='images/placeholder.jpg') }}">
        <img class="im" id="depth-image" alt="Depth Image" src="{{ url_for('static', filename='images/placeholder.jpg') }}">
    </div>
    <form id="uploadForm">
        <label for="file-upload" class="custom-file-upload">
            Upload Image
        </label>
        <input id="file-upload" type="file" name="file" required style="display:none;" />
    </form>
</div>




</body>

</html>